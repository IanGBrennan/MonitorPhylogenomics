---
title: "Body Size Evolution in Monitor Lizards"
author: "Ian G. Brennan"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  #html_document:
  #  toc: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
require("knitr")
knitr::opts_chunk$set(echo = TRUE)
#opts_knit$set(root.dir = "~/path/to/folder/")
```

```{r wrap-hook, eval=T, echo=F}
library(knitr)
hook_output = knit_hooks$get('output')
knit_hooks$set(output = function(x, options) {
  # this hook is used only when the linewidth option is not NULL
  if (!is.null(n <- options$linewidth)) {
    x = knitr:::split_lines(x)
    # any lines wider than n should be wrapped
    if (any(nchar(x) > n)) x = strwrap(x, width = n)
    x = paste(x, collapse = '\n')
  }
  hook_output(x, options)
})
```

# Read Me
This markdown document will walk you through the data and code necessary to repeat the analyses of trait evolution found in our manuscript. All the files and code are available at the  [*GitHub Repository MonitorPhylogenomics*](https://github.com/IanGBrennan/MonitorPhylogenomics).

\  

Start off by loading a few packages that we'll need along the way.
```{r, message=F, warning=F}
library(dplyr)
library(treeplyr)
library(RCurl)
library(phytools)
library(RColorBrewer)
# remember 'plyr' and 'dplyr' conflict, so don't load 'plyr'

#setwd("~/Documents/GitHub")
```

<!--
# read in the tree and data from Github
#gtree <- read.tree(text = getURL("https://raw.githubusercontent.com/IanGBrennan/MonitorPhylogenomics/master/Varanidae_STRICT_HKY_270_con.newick?token=ADMNYR23Q3PA5ESRW6636DC5WJXC4"))
#gdata <- read.csv(text = getURL("https://raw.githubusercontent.com/IanGBrennan/MonitorPhylogenomics/master/Varanus_AllSVL.csv?token=ADMNYR74BITS2S7YELXXSQK5WJU5Q"), header=T)
-->

\pagebreak

# Data Visualization

Now read in and have a quick look at our data.
```{r, eval=T, fig.height=10}
gtree <- read.tree("Varanidae_STRICT_HKY_270_con.newick");
plot.phylo(gtree)
alldata <- read.csv("All_Size_Data.csv", header=T)
head(alldata)

```

\  

Use treeplyr to combine the data, then remove any missing
```{r, eval=T, tidy=T, tidy.opts=list(width.cutoff=60)}
goanna <- make.treedata(gtree, alldata); # summary(goanna)
gf <- filter(goanna, is.na(Tail)==FALSE, is.na(SVL)==FALSE);
```

\  

treeplyr is great because we can use all the tidyverse terms we already love.  
Log-transform the SVL data, and make it a new column  
```{r, eval=T}
gf <- mutate(gf, logSVL = log(gf$dat$SVL))
```

\  

Start visualizing the trait using 'contMap' from 'phytools'
```{r, eval=T, fig.height=10}
obj1 <- contMap(gf$phy, getVector(gf, logSVL), plot=FALSE, outline=F); 
n<-length(obj1$cols); 
obj1$cols[1:n] <- rev(colorRampPalette(brewer.pal(9, "YlGnBu"))(n));
plot(obj1, legend=0.7*max(nodeHeights(obj1$tree)),
     fsize=c(0.7,0.9), lwd=5, border=F); axisPhylo(1, backward=T)
```

\  

Trim the data just down to Australian goannas
```{r, eval=T}
oz.g <- filter(gf, Location == "Australia" & Status == "Extant")
#summary(oz.g)
```

\  

# Packages and Scripts

We need to load a bunch of additional packages and custom scripts, I'll try and explain what they're for briefly.
```{r, message=F, warning=F}
library(parallel)
library(RPANDA)
library(deSolve)
library(rase)
```

\  

This is a collection of additional functions for RPANDA, and includes the new models we'll use later.  
```{r, message=F, warning=F}
source("~/Documents/GitHub/MonitorPhylogenomics/RPANDA_extras.R")
```
These functions make a *Geo Object* from spatial data and your *rase* output.  
```{r, message=F, warning=F}
source("~/Documents/GitHub/MonitorPhylogenomics/CreateGeoObject_fromSP.R")
```
A collection of functions for extracting the AIC values and weights for a set of models.  
```{r, message=F, warning=F}
source("~/Documents/GitHub/MonitorPhylogenomics/Calculate_AICs.R")
```
A function for plotting distribution maps for a set of taxa. This also translates spatial data into spatial geometries and OWin objects.  
```{r, message=F, warning=F}
source("~/Documents/GitHub/MonitorPhylogenomics/plot.distmaps.R")
```
This function processes a *rase* output object and makes distribution objects for ancestral nodes. More on that later...  
```{r, message=F, warning=F}
source("~/Documents/GitHub/MonitorPhylogenomics/process.rase.R")
```

The likelihood optimization can be hard given the number of parameters we're estimating, so I've created a function 'search.surface' 
that uses mclapply to fit the model a number of times with different starting parameters. It starts by creating sets of plausible starting parameters from across the surface, fits them and gives you the output either the best model fit, or all of the model fits. This function/method won't be necessary for simpler models like the BM or OU, and as implemented it won't work on models outside of the RPANDA framework.   
```{r, message=F, warning=F}
source("~/Documents/GitHub/MonitorPhylogenomics/search.surface.R")
```

\pagebreak

# Trait and Spatial Evolution of Australian *Varanus*

--- 

We're going to turn our focus over to the Australian radiation of monitor lizards now, so we can load some existing files.  
```{r}
tutorial <- readRDS("~/Documents/GitHub/MonitorPhylogenomics/Goanna_Walkthrough.RDS")
# this includes a tree, size data, distribution data, and a processed rase object
names(tutorial)
```
This should include our phylogeny of Australian monitor lizards (**phy**), corresponding body size information (**body.size**), a table of their occurrence records (**distribution.data**), a process *rase* file of spatial evolution (**rase.data**), and a geography object for use with *RPANDA* (**geo.object**).

## Spatial Data Processing

---

\  

### Spatial Data at the Tips
Now we can plot the distributions of extant (tip) taxa.  
*plot.distmaps* will loop through each taxon in the distribution dataframe (goanna.dist), and return a list three types of objects:  
$\bullet$ **SpatialPoints** which have been made from the lat/longs.  
$\bullet$ **ConvexHulls** which are distribution shape objects  
$\bullet$ **OWin** objects which are another type of distribution shape object  
```{r, eval=T}
head(tutorial$distribution.data)
tips <- plot.distmaps(tutorial$distribution.data, 
                      new.directory = NULL, 
                      point.width = 0.25)
```

\  

We can quickly look at what these things are. Each object is also indexed for each tip taxon.  
First check out the *SpatialPoints* objects
```{r}
head(tips$SpatialPoints$Varanus.eremius)
```

\  

Next we can plot the shape of this distribution, which is an amalgamation of the point data with a buffer (of your choosing) around each point.  
```{r}
plot(tips$ConvexHulls$Varanus.eremius)
```

Finally, the *OWin* object for a given species should be identical to that species' *ConvexHull*
```{r}
plot(tips$OWin$Varanus.eremius)
```

\  

We can see what this actually looks like on a map too:
```{r, eval=T, message=F}
sbbox <- make_bbox(lon = tutorial$distribution.data$Longitude, 
                   lat = tutorial$distribution.data$Latitude, f = .1)
sq_map <- get_stamenmap(bbox = sbbox, zoom = 3, maptype = "toner")

fortified.data <- fortify(tips$ConvexHulls$Varanus.eremius)
print((ggmap(sq_map)
      + geom_point(data = filter(tutorial$distribution.data, 
                   Name_in_Tree == "Varanus.eremius"), 
                   mapping = aes(x=Longitude, y=Latitude), 
                   color="tomato3", size=5, alpha=0.5)))
```

\  

### Running *rase*
Ok, now we can move on. Quickly sort the data to make sure the order matches the tree appropriately
```{r}
tree_poly <- name.poly(tips$OWin, 
                       tutorial$phy, 
                       poly.names = unique(tutorial$distribution.data$Name_in_Tree))
```

Now we can run the *rase* MCMC sampler. I'm not going to actually run it here because it would take too long, so instead we'll load an object I've already run.
```{r, eval=F}
res <- rase(tutorial$phy, 
            tree_poly, 
            niter=10000, 
            logevery = 100)
```

If you have actually run it, then extract and plot the MCMC output to check for convergence.
```{r, eval=F}
resmc <- mcmc(res, start=(length(res[,1])*.2)) # remove 20% as burnin
par(mar=c(1,1,1,1))
plot(resmc)
```
### Processing *rase* Outputs
If/when you do run *rase* you'll need to process the output so we can use it with the *process.rase* function. It will do pretty much the same thing that the *plot.distmaps* function did, but for ancestral nodes/distributions. I'll explain how you use it here.
```{r, tidy=T,eval=F}
process.rase <- function(mcmc.object, 
                         distribution, 
                         new.directory=NULL,
                         remove.extralimital=NULL, 
                         range.shape, 
                         point.width=1)
```
Here are the basics:  
    $\bullet$ **mcmc.object**---is your *rase* mcmc output file  
    $\bullet$ **distribution**---is the data frame of distribution information  
    $\bullet$ **new.directory**---if you'd like to see the distributions of ancestral nodes, specify an output folder.  
    $\bullet$ **remove.extralimital**---because *rase* is a Brownian Motion dispersal process you might end up with samples in the ocean. We can remove these if we have a SHP file of the borders of our region, here Australia. Defaults to NULL if you don't have one.  
    $\bullet$ **range.shape**---if you set '*remove.extralimital*=TRUE', then the function expects the path to a .shp/x file.  
    $\bullet$ **point.width**---is the buffer size for your ancestral samples.  
    
We've already loaded a processed *rase* object, so no need to make a new one.
```{r}
# these are the objects in the rase list
names(tutorial$rase.data)
```

\  

### Ancestral Spatial Data
This object has all the same things as the object from *plot.distmaps*, in that you have *SpatialPoints*, *ConvexHulls*, and *OWin* shapes, as well as the raw distribution data *DistData*. The difference is that all of this information is for ancestral nodes (node numbers according to *ape*).  
Quickly look at this information if you're interested. Our tree has 31 tips, so the root node should be n32. 
```{r}
# get the node number for the MRCA of V.gilleni and V.bushi
getMRCA(tutorial$phy, c("Varanus.gilleni", "Varanus.bushi"))
```
We know it's node 43 ('n43' in my notation), so we can plot the distribution of this ancestor.
```{r, eval=T}
print((ggmap(sq_map)
       + geom_point(data = filter(tutorial$rase.data$DistData, 
                                  Name_in_Tree == "n43"),
                   mapping = aes(x=Longitude, y=Latitude), 
                   color="tomato3", size=5, alpha=0.5)))
```

***
### Making *GeoObjects*
Great, we're ready to move on to making our *GeoObject*  
In the script *CreateGeoObject_fromSP.R* there are actually two functions:  
*CreateGeoObject_SP* works with a single tree, distribution data frame, and processed *rase* object.  
*CreateCoEvoGeoObject_SP* does much the same, but for the co-evolutionary scenario with two trees, a distribution data frame, and two processed *rase* objects. 
```{r, eval=F}
goanna.geo.object <- CreateGeoObject_SP(tutorial$phy, 
                                        tutorial$distribution.data, 
                                        point.width=0.25)
```

Again, instead of running that, we've already read in an existing file. If you decide to run it, the function shouldn't take more than a minute.  
```{r}
names(tutorial$geo.object)
```

The *GeoObject* holds a lot of information, so it's not really useful to go through everything, but I'll try to make a short explanation so it isn't a total black box.  
$\bullet$ **geography.object** is a list of the interaction matrices for all taxa that exist at a given time in the tree.  
```{r}
tutorial$geo.object$geography.object[[3]]
# this shows the interaction matrix at the third time point (third cladogenetic event)
```
$\bullet$ **times** are the occurrence times of the cladogenetic events, as time since the root (0).  
```{r}
tutorial$geo.object$times
# goanna.geo.object$times[[3]] is the time of the matrix above
```
$\bullet$ **spans** are the amount of time between each cladogenetic event.   
```{r}
tutorial$geo.object$spans
```
$\bullet$ **name.matrix** is a matrix of all the internal node names and associated information. The left column are node/tip numbers. The center column is the taxon name of the edge which descends from that node, and the right column is the node that the edge ends at. Each node appears in the left column twice because it gives rise to two edges, which end at two different nodes (or tips). This is probably of no interest to anyone.  
```{r}
head(tutorial$geo.object$name.matrix)
```

\  

We now have a *GeoObject* that we can use for the geography-informed models. Next up we'll start fitting some models of trait evolution. 

\pagebreak


## Fitting Models of Trait Evolution

---

Our full tree includes a few taxa which are not recognized as full species (*Varanus acanthurus brachyurus*, *V.a.insulanicus*, *et al.*), so we'll drop those from the tree for the trait evolution model fitting. 
```{r, eval=T, tidy=T, tidy.opts=list(width.cutoff=60)}
goanna <- make.treedata(tutorial$phy, tutorial$size.data); # summary(goanna)
goanna <- mutate(goanna, logSVL = log(Body_Length))
```

We can have a look at the *search.surface* function quickly to see what it does and how it works.
```{r, tidy=T, tidy.opts=list(width.cutoff=50), eval=F}
search.surface <- function(model, n.iter = 10, traits, n.proc = 8, 
                           no.S=1, results=c("best", "all"), start.params=NULL)
```

The function lets us control a few things via the commands:  
    $\bullet$ **model**---the model of interest, you must have built this already   
    $\bullet$ **n.iter**---the number of model fittings you'd like completed, defaults to 10  
    $\bullet$ **traits**---the input traits for model fitting   
    $\bullet$ **n.proc**---number of processors. this function will fit the model in parallel.  
    $\bullet$ **no.S**--- number of S parameters in the model, defaults to 1. if your model requires estimating/fitting more than 1 S parameter, say so  
    $\bullet$ **results**---would you like the function to report just the best fitting run, or all the results from each fit attempt      

Now we need to build & fit a set of models just to the goanna data to compare with previous hypotheses about how body size variation evolved.  
Let's start with the basics (BM, OU), then move into some more complex models.  

```{r, eval=T, echo=F}
load("~/Documents/GitHub/MonitorPhylogenomics/Varanus_Empirical_ModelObjects.RData")
```

### Brownian Motion (BM)
Now the standard Brownian Motion (BM) model (Felsenstein, 1985)
```{r, eval=F}
modelBM <- createModel(goanna$phy, 
                       keyword="BM")
```
```{r, eval=T, linewidth=80}
show(modelBM)
```
```{r, eval=F}
fitBM <- fitTipData(modelBM, 
                    treeplyr::getVector(goanna, logSVL), 
                    GLSstyle=T)
show(fitBM)
```
### Ornstein-Uhlenbeck (OU)
Next an Ornstein-Uhlenbeck (OU) model, which is really just BM with a single "adaptive optimum"
```{r, eval=F}
modelOU <- createModel(goanna$phy, 
                       keyword="OU")
```
```{r, eval=T, linewidth=80}
show(modelOU)
```
```{r, eval=F}
fitOU <- fitTipData(modelOU, 
                    treeplyr::getVector(goanna, logSVL), 
                    GLSstyle=T)
show(fitOU)
```
### Multi-Optimum OU (OUM)
Let's fit a model for goannas based on habitat partitioning (Collar et al. 2011).  
This is a multi-OU model with different "adaptive optima" per habitat/niche type.
```{r, eval=F, message=F, warning=F}
library(OUwie)
source("~/Documents/GitHub/MonitorPhylogenomics/make.OUwie.input_Script.R")
goanna.habitat <- make.OUwie.input(data=goanna$dat, 
                                   regime=goanna$dat$Habitat,
                                   taxa=goanna$phy$tip.label,
                                   phy=goanna$phy,
                                   trait=goanna$dat$logSVL)
plot(goanna.habitat$regime.simm)
fitOUM <- OUwie(goanna.habitat$regime.simm, 
                goanna.habitat$combined, 
                model="OUM", 
                simmap.tree=T)
fitOUM
```
### Phenotypic Matching (PM)
Build the PM model, which estimates a single S parameter
```{r, eval=F, warning=F}
modelPM <- createModel(goanna$phy, 
                       keyword="PM")
```
```{r, eval=T, linewidth=80}
show(modelPM)
```
```{r, eval=F}
fitPM <- fitTipData(modelPM, 
                    treeplyr::getVector(goanna, logSVL), 
                    GLSstyle=T)
show(fitPM)
```

The geography-informed models below require a processed rase object, luckily we already have one of those!
### Phenotypic Matching with Geography (PM~geo~)
Build the PM~geo~ model, which estimates a single S parameter, and includes geography
```{r, eval=F}
modelPM_geo <- createGeoModel(goanna$phy, 
                              tutorial$geo.object, 
                              keyword="PM+geo")
```
```{r, eval=T, linewidth=80}
show(modelPM_geo)
```
```{r, eval=F}
fitPM_geo <- search.surface(modelPM_geo, 
                            n.iter=8, 
                            traits=treeplyr::getVector(goanna, logSVL), 
                            n.proc=4, 
                            no.S=1, 
                            results="best") # this took ~1 min
show(fitPM_geo)
```
### Phenotypic Matching without the OU process (PMOU~less~)
Build the PM OU-less model, which estimates a single S, no alpha, and includes geography
```{r, eval=F}
modelPMOU_geo <- createGeoModel(goanna$phy, 
                                tutorial$geo.object, 
                                keyword="PMOU+geo")
```
```{r, eval=T, linewidth=80}
show(modelPMOU_geo)
```
```{r, eval=F}
fitPMOU_geo <- fitTipData(modelPMOU_geo, 
               treeplyr::getVector(goanna, logSVL), 
               GLSstyle=T)
show(fitPMOU_geo)
```
### Summarizing Model Fit
If you've run the above models, and want to keep the results, you can do that here
```{r, eval=F}
model.list <- c("BM", "OU", "PM", "PM_geo", "PMOU_geo", "OUM")
fit.res <- lapply(model.list, 
                  function(x) get(paste0("fit", x))); 
names(fit.res) <- model.list
save.all.models <- paste0("~/Documents/GitHub/MonitorPhylogenomics/", 
                          "Varanus_Empirical_ModelObjects.RData")
save(modelBM, fitBM,
     modelOU, fitOU,
     modelPM, fitPM,
     modelPM_geo, fitPM_geo,
     modelPMOU_geo, fitPMOU_geo,
     fitOUM, fit.res,
     file=save.all.models)
```

To save time, I haven't run these models here, so we'll read in an r data file with the models instead.
```{r}
load("~/Documents/GitHub/MonitorPhylogenomics/Varanus_Empirical_ModelObjects.RData")
```

Summarize the model fits
```{r, eval=T, linewidth=80}
multiphy.AIC(prefix="fit", phylo=goanna$phy, 
             models=c("BM", "OU", "PM_geo", "PMOU_geo", "OUM"))
```
What we find is pretty strong support (70% AICc weight) for the geographically-informed Phenotypic Matching model (also known as Matching Competition), without the OU parameter of the original model. That's interesting because the interaction parameter *S* is negative, suggesting that body size of Australian monitor lizards has evolved as result of lineage interactions.  

If you wanted to simulate some data to see what it looks like under the inferred parameters. Yours might look a little different from the one in this PDF, no worries.
```{r, eval=T, warning=F, message=F}
simulateTipData(modelPMOU_geo, fitPMOU_geo$inferredParams, method=2)
```
### Model Recoverability
We could also quickly check that the inferred params result in simulated data that can recover the correct model:
```{r, eval=F, warning=F, message=F}
# simulate under PMOUgeo model
testPMOUg <- simulateTipData(modelPMOU_geo, fitPMOU_geo$inferredParams, method=1)
head(testPMOUg)
# create and fit the BM model to the simulated data
test_modelBM <- createModel(goanna$phy, 
                            keyword="BM")
test_fitBM <- fitTipData(test_modelBM, 
                         testPMOUg, 
                         GLSstyle=T)
show(test_fitBM)

# create and fit the PMOUgeo model to the simulated data
test_modelPMOU_geo <- createGeoModel(goanna$phy, 
                                     tutorial$geo.object, 
                                     keyword="PMOU+geo")
test_fitPMOU_geo <- fitTipData(test_modelPMOU_geo, testPMOUg, GLSstyle=T)
show(test_fitPMOU_geo)
        
# Summarize the model fits
multiphy.AIC(prefix="test_fit", goanna$phy, c("BM", "PMOU_geo"))
```
We see that from simulated data the PMOU_geo model is definitely distinguishable from Brownian Motion (99.8% AICc weight for the data I simulated).  

\pagebreak 

Reminder: you can check the composition of a model using '@', e.g.: 
```{r, eval=T}
modelPM_geo@aAGamma(3, fitPM_geo$inferredParams);
```
And see what the interaction matrices would look like under estimated parameters:
```{r, eval=T}
modelPM_geo@aAGamma(3, fitPM_geo$inferredParams)$A / fitPM_geo$inferredParams[5]
```


\pagebreak

# Building and Fitting Coevolutionary Models of Trait Evolution

---

In this manuscript we also further developed the methods of Manceau et al. (201X) that allow the users to account for the influence of two clades on trait evolution. This can be imagined as phenotypic matching like in some butterflies and flowers (positive *S*) or as phenotypic competition like is expected in local organismal assemblages (negative *S*).  

In general the steps follow the same process as with one clade. We need to:
1. Read in trees, trait, and distributional data.
2. Run *rase* to get ancestral distributions.
3. Determine overlapping taxa and build interaction matrices.
4. Fit models of trait evolution.  

\  

We already have our monitor lizard tree and data, but we'll start somewhere near scratch again, in case you've just jumped to this point.  
```{r}
coevo <- readRDS("~/Documents/GitHub/MonitorPhylogenomics/CoEvo_Walkthrough.RDS")
names(coevo)
```
This includes two tree files (**goanna.tree**, **marsupial.tree**), corresponding body size information (**size.data**), occurrence records for both clades (**goanna.distribution**, **marsupial.distribution**), processed *rase* objects (**goanna.rase**, **marsupial.rase**), and a joint geography object for use with *RPANDA* (**joint.geo.object**). 

## Coevolutionary Spatial Data Processing

---

### Spatial Data at the Tips
Now we can plot the distributions of extant (tip) taxa.  
*plot.distmaps* will loop through each taxon in the distribution dataframes, and return a list three types of objects:  
$\bullet$ **SpatialPoints** which have been made from the lat/longs.  
$\bullet$ **ConvexHulls** which are distribution shape objects  
$\bullet$ **OWin** objects which are another type of distribution shape object  
```{r, eval=T}
head(coevo$marsupial.distribution)
marsupial.tips <- plot.distmaps(coevo$marsupial.distribution, 
                                new.directory = NULL, 
                                point.width = 0.25)
```
To speed this all up I won't do it for the goannas, but I'll leave this here.
```{r, eval=F}
head(coevo$goanna.distribution)
goanna.tips <- plot.distmaps(coevo$goanna.distribution, 
                             new.directory = NULL, 
                             point.width = 0.25)
```

\  

We can quickly look at what these things are. Each object is also indexed for each tip taxon.  
First check out the *SpatialPoints* objects
```{r}
head(marsupial.tips$SpatialPoints$Dasyurus.maculatus)
```

\  

Next we can plot the shape of this distribution, which is an amalgamation of the point data with a buffer (of your choosing) around each point.  
```{r}
plot(marsupial.tips$ConvexHulls$Dasyurus.maculatus)
```

Finally, the *OWin* object for a given species should be identical to that species' *ConvexHull*
```{r}
plot(marsupial.tips$OWin$Dasyurus.maculatus)
```

\  

We can see what this actually looks like on a map too:
```{r, eval=T, message=F}
sbbox <- make_bbox(lon = coevo$marsupial.distribution$Longitude, 
                   lat = coevo$marsupial.distribution$Latitude, f = .1)
sq_map <- get_stamenmap(bbox = sbbox, zoom = 3, maptype = "toner")

fortified.data <- fortify(marsupial.tips$ConvexHulls$Dasyurus.maculatus)
print((ggmap(sq_map)
      + geom_point(data = filter(coevo$marsupial.distribution, 
                   Name_in_Tree == "Dasyurus.maculatus"), 
                   mapping = aes(x=Longitude, y=Latitude), 
                   color="tomato3", size=5, alpha=0.5)))
```

\  

### Running *rase*
Ok, now we can move on. Quickly sort the data to make sure the order matches the tree appropriately
```{r}
tree_poly <- name.poly(marsupial.tips$OWin, 
                       coevo$marsupial.tree, 
                       poly.names = unique(coevo$marsupial.distribution$Name_in_Tree))
```

Now we can run the *rase* MCMC sampler. I'm not going to actually run it here because it would take too long, so instead we'll load an object I've already run.
```{r, eval=F}
res <- rase(coevo$marsupial.tree, 
            tree_poly, 
            niter=10000, 
            logevery = 100)
```

If you have actually run it, then extract and plot the MCMC output to check for convergence.
```{r, eval=F}
resmc <- mcmc(res, start=(length(res[,1])*.2)) # remove 20% as burnin
par(mar=c(1,1,1,1))
plot(resmc)
```

If/when you do run *rase* you'll need to process the output so we can use it with the *process.rase* function. It will do pretty much the same thing that the *plot.distmaps* function did, but for ancestral nodes/distributions. I'll explain how you use it here.
```{r, tidy=T,eval=F}
process.rase <- function(mcmc.object, 
                         distribution, 
                         new.directory=NULL,
                         remove.extralimital=NULL, 
                         range.shape, 
                         point.width=1)
```
Here are the basics:  
    $\bullet$ **mcmc.object**---is your *rase* mcmc output file  
    $\bullet$ **distribution**---is the data frame of distribution information  
    $\bullet$ **new.directory**---if you'd like to see the distributions of ancestral nodes, specify an output folder.  
    $\bullet$ **remove.extralimital**---because *rase* is a Brownian Motion dispersal process you might end up with samples in the ocean. We can remove these if we have a SHP file of the borders of our region, here Australia. Defaults to NULL if you don't have one.  
    $\bullet$ **range.shape**---if you set '*remove.extralimital*=TRUE', then the function expects the path to a .shp/x file.  
    $\bullet$ **point.width**---is the buffer size for your ancestral samples.  
    
We've already loaded a processed *rase* object for the goannas, so no need to make a new one.
```{r}
# these are the objects in the rase list
names(coevo$marsupial.rase)
```

\  

### Ancestral Spatial Data
This object has all the same things as the object from *plot.distmaps*, in that you have *SpatialPoints*, *ConvexHulls*, and *OWin* shapes, as well as the raw distribution data *DistData*. The difference is that all of this information is for ancestral nodes (node numbers according to *ape*).  
Quickly look at this information if you're interested. Our tree has 31 tips, so the root node should be n32. 
```{r}
# get the node number for the MRCA of two quolls D.maculatus and D.viverrinus
getMRCA(coevo$marsupial.tree, c("Dasyurus.maculatus", "Dasyurus.viverrinus"))
```
We know it's node 115 ('n115' in my notation), so we can plot the distribution of this ancestor.
```{r, eval=T}
print((ggmap(sq_map)
       + geom_point(data = filter(coevo$marsupial.rase$DistData, 
                                  Name_in_Tree == "n115"),
                   mapping = aes(x=Longitude, y=Latitude), 
                   color="tomato3", size=5, alpha=0.5)))
```

### Making *CoEvoGeoObjects*
Great, we're ready to move on to making our *CoEvoGeoObject*  
In the script *CreateGeoObject_fromSP.R* there are actually two functions:  
*CreateGeoObject_SP* works with a single tree, distribution data frame, and processed *rase* object.  
*CreateCoEvoGeoObject_SP* does much the same, but for the co-evolutionary scenario with two trees, a distribution data frame, and two processed *rase* objects. 
We'll use the second one here because we're working with two trees.
```{r, eval=F}
coevo.dist <- rbind(coevo$goanna.distribution, coevo$marsupial.distribution)

joint.geo.object <- CreateCoEvoGeoObject_SP(phy1=coevo$goanna.tree, 
                                            phy2=coevo$marsupial.tree, 
                                            map=coevo.dist,
                                            rase.obj1=coevo$goanna.rase, 
                                            rase.obj2=coevo$dasyurid.rase, 
                                            point.width=0.25)
```

Again, instead of running that, we've already read in an existing file. If you decide to run it, the function shouldn't take more than a minute.  
```{r}
names(coevo$joint.geo.object)
```

The *CoEvoGeoObject* holds a lot of information, so it's not really useful to go through everything, but I'll try to make a short explanation so it isn't a total black box. 

\  

$\bullet$ **geography.object** is a list of the interaction matrices for all taxa that exist at a given time in the tree.  
```{r}
coevo$joint.geo.object$geography.object[[3]]
# this shows the interaction matrix at the third time point (third cladogenetic event)
```
$\bullet$ **times** are the occurrence times of the cladogenetic events, as time since the root (0).  
```{r}
coevo$joint.geo.object$times
# goanna.geo.object$times[[3]] is the time of the matrix above
```
$\bullet$ **spans** are the amount of time between each cladogenetic event.   
```{r}
coevo$joint.geo.object$spans
```
$\bullet$ **startingTimes**
```{r}
head(coevo$joint.geo.object$startingTimes)
```
$\bullet$ **endTimes**
```{r}
head(coevo$joint.geo.object$endTimes)
```

\  

We now have a *CoEvoGeoObject* that we can use for the geography-informed models. So, we'll start fitting some models of trait evolution. 

\pagebreak

## Coevolutionary Model Fitting

---

```{r, eval=T, echo=F}
load("/Users/Ian/Google.Drive/R.Analyses/Varanus_Project/Varanus.Marsupial_Empirical_ModelObjects.RData")
```

Combine the trait data for both phylogenies
```{r, eval=T}
joint.traits <- log(coevo$size.data$Body_Length)
names(joint.traits) <- coevo$size.data$Name_in_Tree
head(joint.traits)
```

Combine the trees too.
```{r, eval=T}
joint.tree <- c(coevo$goanna.tree, coevo$marsupial.tree); 
class(joint.tree) <- "multiPhylo"
```
### Co-Brownian Motion (CoBM)
Design then fit BM model with a shared sigma (rate) parameter.
**Warning**: This is much slower than fitting BM to two trees with the *ratebytree* function in *phytools*. I'd suggest you use that one, and it's included later on.
```{r, eval=T, linewidth=80}
modelCoBM <- createModelCoevolution(coevo$marsupial.tree, 
                                    coevo$goanna.tree, 
                                    keyword="CoBM")
```
```{r, eval=T, linewidth=80}
show(modelCoBM)
```
```{r, eval=F}
ssCoBM <- fitTipData(modelCoBM, 
                      joint.traits, 
                      GLSstyle=T)
```
### Co-Ornstein Uhlenbeck (CoOU)
Design then fit the OU model with shared sigma (rate) and alpha (constraint) parameters.
**Warning**: This is much slower than fitting OU to two trees with the *ratebytree* function in *phytools*. I'd suggest you use that one, and it's included later on.
```{r, eval=T, linewidth=80}
modelCoOU <- createModelCoevolution(coevo$marsupial.tree, 
                                    coevo$goanna.tree, 
                                    keyword="CoOU")
```
```{r, eval=T, linewidth=80}
show(modelCoOU)
```
```{r, eval=F}
ssCoOU <- fitTipData(modelCoOU, 
                      joint.traits, 
                      GLSstyle=T)
```
### Generalist Matching Mutualism (GMM)
Design the GMM model, then fit it to our Trees/Data (assumes interaction only between taxa in DIFFERENT trees)
```{r, eval=T, linewidth=80, message=F}
modelGMM <- createModelCoevolution(coevo$marsupial.tree, 
                                   coevo$goanna.tree,
                                   keyword="GMM")
```
```{r, eval=T, linewidth=80}
show(modelGMM)
```
```{r, eval=F}
ssGMM <- search.surface(modelGMM, 
                        n.iter=8, 
                        traits=joint.traits, 
                        n.proc=4, 
                        results="best") # this took ~1min
```
### Generalist Matching Mutualism--All (GMM~all~)
Design the GMM~all~ model, then fit it to our Trees/Data (assumes interaction between ALL taxa in both trees)
```{r, eval=T, linewidth=80}
modelGMM_all <- createModelCoevolution(coevo$marsupial.tree,
                                       coevo$goanna.tree, 
                                       keyword="GMM_all")
```
```{r, eval=T, linewidth=80}
show(modelGMM_all)
```
```{r, eval=F}
ssGMM_all <- search.surface(modelGMM_all, 
                            n.iter=8, 
                            traits=joint.traits, 
                            n.proc=4, 
                            results="best") # this took ~1min
```
### CoEvolution (CoEvo)
Design the CoEvo model, (correct implementation of geography with the GMM model, but no intra-clade competition, meaning geography only influences interactions of taxa in opposing trees)
```{r, eval=T, linewidth=80}
modelCoEvo <- createModelCoevolution(coevo$marsupial.tree,
                                     coevo$goanna.tree, 
                                     geo.object = coevo$joint.geo.object, 
                                     keyword="CoEvo")
```
```{r, eval=T, linewidth=80}
show(modelCoEvo)
```
```{r, eval=F}
ssCoEvo <- search.surface(modelCoEvo, 
                          n.iter=8, 
                          traits=joint.traits, 
                          n.proc=4, 
                          results="best") # this took ~16 minutes (12 another time)
```
### CoEvolution--All (CoEvo~all~)
Design the CoEvo~all~ model, (correct implementation of geography with the GMM model, but no intra-clade competition)
```{r, eval=T, linewidth=80}
modelCoEvo_all <- createModelCoevolution(coevo$marsupial.tree,
                                     coevo$goanna.tree, 
                                     geo.object = coevo$joint.geo.object, 
                                     keyword="CoEvo_all")
```
```{r, eval=T, linewidth=80}
show(modelCoEvo_all)
```
```{r, eval=F}
ssCoEvo_all <- search.surface(modelCoEvo_all, 
                              n.iter=8, 
                              traits=joint.traits, 
                              n.proc=4, 
                              results="best") # this took ~
```
### CoEvolution--Split (CoEvo~split~)
Build the CoEvo~split~ model with split intra/inter-clade S (correct implemenation of geography with the GMM model, intra (S2) and interclade (S1) interactions are different)
```{r, eval=T, linewidth=80}
modelCoEvo_Split <- createModelCoevolution(coevo$marsupial.tree,
                                     coevo$goanna.tree, 
                                     geo.object = coevo$joint.geo.object, 
                                     keyword="CoEvo_Split")
```
```{r, eval=T, linewidth=80}
show(modelCoEvo_Split)
```
```{r, eval=F}
ssCoEvo_Split <- search.surface(modelCoEvo_Split, 
                                n.iter=8, 
                                traits=joint.traits, 
                                n.proc=4, no.S=2, 
                                results="best") 
# this took ~23 minutes (13 another time)
```
### Co-Phenotypic Matching (CoPM)
Build the CoPM model, which estimates the PM model on two trees (no interclade interaction), but fits only a single interaction parameter (S) two both trees
```{r, eval=T, linewidth=80}
modelCoPM <- createModelCoevolution(coevo$marsupial.tree,
                                    coevo$goanna.tree,
                                    keyword="CoPM")
```
```{r, eval=T, linewidth=80}
show(modelCoPM)
```
```{r, eval=F}
ssCoPM <- search.surface(modelCoPM, 
                         n.iter=8, 
                         traits=joint.traits, 
                         n.proc=4, 
                         results="best") # this took ~
```
### Co-Phenotypic Matching with Geography (CoPM~geo~)
Expand the CoPM~geo~ model to incorporate geography, (same S, interaction only between overlapping taxa within a tree)
```{r, eval=T, linewidth=80}
modelCoPM_geo <- createModelCoevolution(coevo$marsupial.tree,
                                     coevo$goanna.tree,
                                     geo.object = coevo$joint.geo.object, 
                                     keyword="CoPM_geo")
```
```{r, eval=T, linewidth=80}
show(modelCoPM_geo)
```
```{r, eval=F}
ssCoPM_geo <- search.surface(modelCoPM_geo, 
                             n.iter=8, 
                             traits=joint.traits, 
                             n.proc=4, 
                             results="best") # this took ~11 minutes (13 another time)
```
### Joint Phenotypic Matching (JointPM)
Build the JointPM model, which estimates separate interaction parameters (S1, S2) for the two trees. Interaction only occurs within a tree.
```{r, eval=T, linewidth=80}
modelJointPM <- createModelCoevolution(coevo$marsupial.tree,
                                     coevo$goanna.tree, 
                                     keyword="JointPM")
```
```{r, eval=T, linewidth=80}
show(modelJointPM)
```
```{r, eval=F}
ssJointPM <- search.surface(modelJointPM, 
                            n.iter=8, 
                            traits=joint.traits, 
                            n.proc=4, 
                            no.S=2, 
                            results="best") # this took ~
```
### Joint Phenotypic Matching with Geography (JointPM~geo~)
Build the JointPM~geo~ model which incorporates geography and estimates separate interaction parameters (S1, S2) for the two trees. Interaction only occurs within a tree.
```{r, eval=T, linewidth=80}
modelJointPM_geo <- createModelCoevolution(coevo$marsupial.tree,
                                     coevo$goanna.tree, 
                                     geo.object = coevo$joint.geo.object, 
                                     keyword="JointPM_geo")
```
```{r, eval=T, linewidth=80}
show(modelJointPM_geo)
```
```{r, eval=F}
ssJointPM_geo <- search.surface(modelJointPM_geo, 
                                n.iter=8, 
                                traits=joint.traits, 
                                n.proc=4, 
                                no.S=2, 
                                results="best") # this took ~
```
### Phenotypic Matching without the OU process (PMOU~less~)
Create and fit the simplified PM model PMOU~less~ (no drift) for goannas
```{r, eval=T, linewidth=80}
modelPMOU <- createModel(coevo$goanna.tree, 
                         keyword = "PM_OUless")
```
```{r, eval=T, linewidth=80}
show(modelPMOU)
```
```{r, eval=F}
ssPMOU_g <- search.surface(modelPMOU, 
                           n.iter=8, 
                           traits=gtraits, 
                           n.proc=8, 
                           results="best")
```

Create and fit the simplified PM model PMOU~less~ (no drift) for marsupials
```{r, eval=T, linewidth=80}
modelPMOU <- createModel(coevo$marsupial.tree, 
                         keyword = "PM_OUless")
```
```{r, eval=T, linewidth=80}
show(modelPMOU)
```
```{r, eval=F}
ssPMOU_m <- search.surface(modelPMOU, 
                           n.iter=8, 
                           traits=mtraits, 
                           n.proc=4, 
                           results="best")
ssPMOU <- joint.fit(ssPMOU_g, ssPMOU_m)
```
### Shared/Independent Brownian Motion (BM~shared~, BM~ind~) and Ornstein-Uhlenbeck (OU~shared~, OU~ind~)
Join both trees together into a single multiPhylo object, and the traits into a list of trait matrices
```{r, eval=F}
gtraits <- subset(joint.traits, 
                  names(joint.traits) %in% coevo$goanna.tree$tip.label)
mtraits <- subset(joint.traits, 
                  names(joint.traits) %in% coevo$marsupial.tree$tip.label)

rbt.traits <- NULL; 
rbt.traits[[1]] <- gtraits; 
rbt.traits[[2]] <- mtraits

head(rbt.traits[[1]])
head(rbt.traits[[2]])
```

Fit alternative models (BM, OU) of trait evolution using *ratebytree* in *phytools*, the likelihood of two trees under:  
Brownian Motion (with shared and independent rate parameters)  
```{r, eval=F}
ssrbt.BM <- ratebytree(joint.tree, 
                       rbt.traits, 
                       model="BM")
```
Ornstein Uhlenbeck (with shared and independent rate/alpha parameters)
```{r, eval=F}
ssrbt.OU <- ratebytree(joint.tree, 
                       rbt.traits, 
                       model="OU")
```


\  

### Summarizing Model Fit

Now we want to summarize the model fits
```{r, eval=T, linewidth=80}
allmodels <- multiphy.AIC("ss", 
             joint.tree, 
             models=c("GMM", "GMM_all", "CoEvo", 
                      "CoEvo_Split", "CoPM_geo", 
                      "CoEvo_all", "CoPM", 
                      "JointPM", "JointPM_geo", 
                      "PMOU", "rbt.BM", "rbt.OU"))
```
```{r, eval=T, echo=F}
allmodels$results
allmodels$best.model
allmodels$parameter.estimates
```
```{r, eval=T, echo=F, linewidth=80}
allmodels$model.description
```

A number of these models (GMM, GMM_all, CoPM, etc.) assume that all contemporaneous lineages are interacting with one another, but that's not realistic. The Australian continent is a big place, so let's drop those unrealistic models.
```{r, eval=T, linewidth=80}
modelsubset <- multiphy.AIC("ss", 
             joint.tree, 
             models= c("CoEvo", "CoEvo_Split", 
                       "CoEvo_all", "CoPM_geo",
                       "JointPM_geo", "rbt.BM", "rbt.OU"))
```
```{r, eval=T, echo=F}
modelsubset$results
modelsubset$best.model
modelsubset$parameter.estimates
```
```{r, eval=T, echo=F, linewidth=80}
modelsubset$model.description
```

\  

Compare all the models (then save em)
```{r, eval=F}
model.list <- c("GMM", "GMM_all", 
                "CoEvo", "CoEvo_Split", 
                "CoPM_geo", "CoEvo_all", 
                "CoPM", "JointPM", 
                "JointPM_geo")
all.res <- multiphy.AIC("ss", 
                        joint.tree, 
                        models=model.list)
fit.res <- lapply(model.list, 
                  function(x) get(paste0("ss", x))); 
names(fit.res) <- model.list

save.all.models <- paste0(save.path, 
                          group.name, 
                          "_Empirical_ModelObjects.RData")
save(fit.res, ssGMM, 
     ssGMM_all, ssCoEvo, 
     ssCoEvo_all, ssCoEvo_Split, 
     ssCoPM, ssCoPM_geo, 
     ssJointPM, ssJointPM_geo, 
     ssPMOU, file=save.all.models)
```

Compare just the realistic models (then save em)
```{r, eval=F}
model.list <- c("CoEvo", "CoEvo_Split", 
                "CoEvo_all", "CoPM_geo",
                "JointPM_geo", "rbt.BM", 
                "rbt.OU")
all.res <- multiphy.AIC("ss", 
                        joint.tree, 
                        models=model.list)
fit.res <- lapply(model.list, 
                  function(x) get(paste0("ss", x))); 
names(fit.res) <- model.list
```










