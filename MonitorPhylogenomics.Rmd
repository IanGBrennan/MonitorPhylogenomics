---
title: "Monitor Phylogenomics"
author: "Ian G. Brennan"
date: "25/10/2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Look at our data

```{r, message=F, warning=F}
library(dplyr)
library(treeplyr)
library(RCurl)
library(phytools)
library(RColorBrewer)
# remember 'plyr' and 'dplyr' conflict, so don't load 'plyr'
```

<!--
# read in the tree and data from Github
#gtree <- read.tree(text = getURL("https://raw.githubusercontent.com/IanGBrennan/MonitorPhylogenomics/master/Varanidae_STRICT_HKY_270_con.newick?token=ADMNYR23Q3PA5ESRW6636DC5WJXC4"))
#gdata <- read.csv(text = getURL("https://raw.githubusercontent.com/IanGBrennan/MonitorPhylogenomics/master/Varanus_AllSVL.csv?token=ADMNYR74BITS2S7YELXXSQK5WJU5Q"), header=T)
-->

```{r, eval=T, fig.height=10}
gtree <- read.tree("~/Documents/GitHub/MonitorPhylogenomics/Varanidae_STRICT_HKY_270_con.newick");
plot.phylo(gtree)
alldata <- read.csv("~/Documents/GitHub/MonitorPhylogenomics/All_Size_Data.csv", header=T)
head(alldata)

```

Use treeplyr to combine the data, then remove any missing
```{r, eval=T, tidy=T, tidy.opts=list(width.cutoff=60)}
goanna <- make.treedata(gtree, alldata); # summary(goanna)
gf <- filter(goanna, is.na(Tail)==FALSE, is.na(SVL)==FALSE);
```

\pagebreak

treeplyr is great because we can use all the tidyverse terms we already love.  
Log-transform the SVL data, and make it a new column  
```{r, eval=T}
gf <- mutate(gf, logSVL = log(gf$dat$SVL))
```

Start visualizing the trait using 'contMap' from 'phytools'
```{r, eval=T, fig.height=10}
obj1 <- contMap(gf$phy, getVector(gf, logSVL), plot=FALSE, outline=F); 
n<-length(obj1$cols); 
obj1$cols[1:n] <- rev(colorRampPalette(brewer.pal(9, "YlGnBu"))(n));
plot(obj1, legend=0.7*max(nodeHeights(obj1$tree)),
     fsize=c(0.7,0.9), lwd=5, border=F); axisPhylo(1, backward=T)
```

Trim the data just down to Australian goannas
```{r, eval=T}
oz.g <- filter(gf, Location == "Australia")
#summary(oz.g)
```

We need to load a bunch of additional packages and custom scripts, I'll try and explain what they're for briefly.
```{r, message=F, warning=F}
library(phytools); library(parallel)
library(RPANDA); library(deSolve)
library(rase)
```
This is a collection of additional functions for RPANDA, and includes the new models we'll use later
```{r, message=F, warning=F}
source("~/Documents/GitHub/MonitorPhylogenomics/RPANDA_extras.R")
```
These functions make a *Geo Object* from spatial data and your *rase* output
```{r, message=F, warning=F}
source("~/Documents/GitHub/MonitorPhylogenomics/CreateGeoObject_fromSP.R")
```
A collection of functions for extracting the AIC values and weights for a set of models
```{r, message=F, warning=F}
source("~/Documents/GitHub/MonitorPhylogenomics/Calculate_AICs.R")
```
A function for plotting distribution maps for a set of taxa. This also translates spatial data into spatial geometries and OWin objects.
```{r, message=F, warning=F}
source("~/Documents/GitHub/MonitorPhylogenomics/plot.distmaps.R")
```
This function processes a *rase* output object and makes distribution objects for ancestral nodes. More on that later...
```{r, message=F, warning=F}
source("~/Documents/GitHub/MonitorPhylogenomics/process.rase.R")
```

The likelihood optimization can be hard given the number of parameters we're estimating, so I've created a function 'search.surface' 
that uses mclapply to fit the model a number of times with different starting parameters. It starts by creating sets of plausible starting parameters from across the surface, fits them and gives you the output either the best model fit, or all of the model fits. This function/method won't be necessary for simpler models like the BM or OU, and as implemented it won't work on models outside of the RPANDA framework. 
```{r, message=F, warning=F}
source("~/Documents/GitHub/MonitorPhylogenomics/search.surface.R")
```


## Spatial Data Processing
```{r, eval=T}
goanna.dist <- read.csv("~/Documents/GitHub/MonitorPhylogenomics/CoEvo_Goanna_Distributions.csv", header=T)
head(goanna.dist)
```

We'll be working with spatial data and focusing on the Australian radiation of monitor lizards now, so we'll need to trim the tree down again. We can't use treeplyr this time, so we'll go oldschool.
```{r}
gtree$tip.label[1] <- "Varanus.acanthurus"
gtree$tip.label[18] <- "Varanus.scalaris"
keepers <- intersect(gtree$tip.label, unique(goanna.dist$Name_in_Tree))
gtree <- drop.tip(gtree, setdiff(gtree$tip.label, keepers))
```

Now we can plot the distributions of extant (tip) taxa.  
*plot.distmaps* will loop through each taxon in the distribution dataframe (goanna.dist), and return a list three types of objects:
$\bullet$ SpatialPoints which have been made from the lat/longs.
$\bullet$ ConvexHulls which are distribution shape objects
$\bullet$ OWin objects which are another type of distribution shape object
```{r, eval=T}
tips <- plot.distmaps(goanna.dist, new.directory = NULL, point.width = 0.25)
```
We can quickly look at what these things are. Each object is also indexed for each tip taxon.  
First check out the *SpatialPoints* objects
```{r}
head(tips$SpatialPoints$Varanus.acanthurus)
```
Next we can plot the shape of this distribution, which is an amalgamation of the point data with a buffer (of your choosing) around each point.
```{r}
plot(tips$ConvexHulls$Varanus.acanthurus)
```
Finally, the *OWin* object for a given species should be identical to that species' *ConvexHull*
```{r}
plot(tips$OWin$Varanus.acanthurus)
```

Ok, now we can move on. Quickly sort the data to make sure the order matches the tree appropriately
```{r}
tree_poly <- name.poly(tips$OWin, gtree, poly.names = unique(goanna.dist$Name_in_Tree))
```

Now we can run the *rase* MCMC sampler. I'm not going to actually run it here because it would take too long, so instead we'll load an object I've already run.
```{r, eval=F}
res <- rase(goanna.tree, tree_poly, niter=10000, logevery = 100)
```

If you have actually run it, then extract and plot the MCMC output to check for convergence.
```{r, eval=F}
resmc <- mcmc(res, start=(length(res[,1])*.2)) # remove 20% as burnin
par(mar=c(1,1,1,1))
plot(resmc)
```

If/when you do run *rase* you'll need to process the output so we can use it with the *CreateGeoObject_SP* function. It will do pretty much the same thing that the *plot.distmaps* function did, but for ancestral nodes/distributions. I'll explain how you use it here.
```{r, tidy=T,eval=F}
process.rase <- function(mcmc.object, distribution, new.directory=NULL,
                         remove.extralimital=NULL, range.shape, point.width=1)
```
Here are the basics:  
    $\bullet$ *mcmc.object*---is your *rase* mcmc output file  
    $\bullet$ *distribution*---is the data frame of distribution information  
    $\bullet$ *new.directory*---if you'd like to see the distributions of ancestral nodes, specify an output folder.  
    $\bullet$ *remove.extralimital*---because *rase* is a Brownian Motion dispersal process you might end up with samples in the ocean. We can remove these if we have a SHP file of the borders of our region, here Australia. Defaults to NULL if you don't have one.  
    $\bullet$ *range.shape*---if you set '*remove.extralimital*=TRUE', then the function expects the path to a .shp/x file.  
    $\bullet$ *point.width*---is the buffer size for your ancestral samples.  
    
We'll read in the processed *rase* object instead of making a new one.
```{r}
goanna.rase <- readRDS("~/Documents/GitHub/MonitorPhylogenomics/CoEvo_Varanus.0.25.RASE.RDS")
```
This object has all the same things as the object from *plot.distmaps*, in that you have *SpatialPoints*, *ConvexHulls*, and *OWin* shapes, as well as the raw distribution data *DistData*. The difference is that all of this information is for ancestral nodes (node numbers according to *ape*).  
Quickly look at this information if you're interested. Our tree has 31 tips, so the root node should be n32. 
```{r}
# get the node number for the MRCA of V.gilleni and V.bushi
getMRCA(gtree, c("Varanus.gilleni", "Varanus.bushi"))
# we know it's node 43 ('n43' in my notation), so we can plot the distribution of this ancestor
plot(goanna.rase$ConvexHulls$n43)
```

***

Great, we're ready to move on to making our *GeoObject*  
In the script *CreateGeoObject_fromSP.R* there are actually two functions:  
*CreateGeoObject_SP* works with a single tree, distribution data frame, and processed *rase* object.  
*CreateCoEvoGeoObject_SP* does much the same, but for the co-evolutionary scenario with two trees, a distribution data frame, and two processed *rase* objects. 
```{r, eval=F}
goanna.geo.object <- CreateGeoObject_SP(gtree, goanna.dist, point.width=0.5)
```

Instead of running that, we'll just read in an existing file, but it shouldn't take long if you do run it (~45 seconds or so).  
```{r}
goanna.geo.object <- readRDS("~/Documents/GitHub/MonitorPhylogenomics/Goanna_0.25_geo.object.RDS")
```

The *GeoObject* holds a lot of information, so it's not really useful to go through everything, but I'll try to make a short explanation so it isn't a total black box.  
$\bullet$ *geography.object* is a list of the interaction matrices for all taxa that exist at a given time in the tree.  
```{r}
goanna.geo.object$geography.object[[3]]
# this shows the interaction matrix at the third time point (third cladogenetic event)
```
$\bullet$ *times* are the occurrence times of the cladogenetic events, as time since the root (0).  
```{r}
goanna.geo.object$times
# goanna.geo.object$times[[3]] is the time of the matrix above
```
$\bullet$ *spans* are the amount of time between each cladogenetic event.   
```{r}
goanna.geo.object$spans
```
$\bullet$ *name.matrix* is a matrix of all the internal node names and associated information. The left column are node/tip numbers. The center column is the taxon name of the edge which descends from that node, and the right column is the node that the edge ends at. Each node appears in the left column twice because it gives rise to two edges, which end at two different nodes (or tips). This is probably of no interest to anyone.  

\  

We now have a *GeoObject* that we can use for the geography-informed models. Next up we'll start fitting some models of trait evolution. 

\pagebreak


## Model Fitting

Our tree includes a few taxa which are likely to be elevated to full species (*Varanus acanthurus brachyurus*, *V.a.insulanicus*, *et al.*), but we do not yet treat as full species. We'll drop those from the tree for the trait evolution bit. 
```{r, eval=T, tidy=T, tidy.opts=list(width.cutoff=60)}
goanna <- make.treedata(gtree, alldata); # summary(goanna)
gf <- filter(goanna, is.na(Tail)==FALSE, is.na(SVL)==FALSE);
```

We can have a look at the *search.surface* function quickly to see what it does and how it works.
```{r, tidy=T, tidy.opts=list(width.cutoff=50), eval=F}
search.surface <- function(model, n.iter = 10, traits, n.proc = 8, 
                           no.S=1, results=c("best", "all"), start.params=NULL)
```

The function lets us control a few things via the commands:  
    $\bullet$ *model*---the model of interest, you must have built this already   
    $\bullet$ *n.iter*---the number of model fittings you'd like completed, defaults to 10  
    $\bullet$ *traits*---the input traits for model fitting   
    $\bullet$ *n.proc*---number of processors. this function will fit the model in parallel.  
    $\bullet$ *no.S*---defaults to 1. if your model requires estimating/fitting more than 1 S parameter, say so  
    $\bullet$ *results*---would you like the function to report just the best fitting run, or all the results from each fit attempt      

Now we need to build & fit a set of models just to the goanna data to compare with previous hypotheses about how body size variation evolved.  
Let's start with the basics (BM, OU), then move into some more complex models.  

Now the standard Brownian Motion (BM) model (Felsenstein, 1985)
```{r, eval=F}
modelBM <- createModel(oz.g$phy, keyword="BM")
show(modelBM)
fitBM <- fitTipData(modelBM, getVector(oz.g, logSVL), GLSstyle=T)
show(fitBM)
```

Next an Ornstein-Uhlenbeck (OU) model, which is really just BM with a single "adaptive optimum"
```{r, eval=F}
modelOU <- createModel(oz.g$phy, keyword="OU")
show(modelOU)
fitOU <- fitTipData(modelOU, getVector(oz.g, logSVL), GLSstyle=T)
show(fitOU)
```

Let's fit a model for goannas based on habitat partitioning (Collar et al. 2011).  
This is a multi-OU model with different "adaptive optima" per habitat/niche type.
```{r, eval=F, message=F, warning=F}
library(OUwie)
source("/Users/Ian/Google.Drive/R.Analyses/Convenient Scripts/make.OUwie.input_Script.R")
goanna.habitat <- make.OUwie.input(data=oz.g$dat, regime=oz.g$dat$Habitat,
                 taxa=oz.g$phy$tip.label, phy=oz.g$phy, trait=oz.g$dat$logSVL)
fitOUM <- OUwie(goanna.habitat$regime.simm, goanna.habitat$combined, model="OUM", simmap.tree=T)
```

Build the PM model, which estimates a single S parameter
```{r, eval=F, warning=F}
modelPM <- createModel(oz.g$phy, keyword="PM")
show(modelPM)
fitPM <- fitTipData(modelPM, getVector(oz.g, logSVL), GLSstyle=T)
show(fitPM)
```

The geography-informed models below require a processed rase object, luckily we already have one of those!

Build the PM+geo model, which estimates a single S parameter, and includes geography
```{r, eval=F}
modelPMgeo <- createGeoModel(oz.g$phy, goanna.geo.object, keyword="PM+geo")
fitPM_geo <- search.surface(modelPMgeo, n.iter=8, traits=gtraits, 
                            n.proc=4, no.S=1, results="best") # this took ~1 min
```

Build the PM OU-less model, which estimates a single S, no alpha, and includes geography
```{r, eval=F}
modelPMOU_geo <- createGeoModel(goanna.tree, goanna.geo.object, keyword="PMOU+geo")
fitPMOU_geo <- fitTipData(modelPMOU_geo, gtraits, GLSstyle=T)
```

To save time, I haven't run these models here, so we'll read in an r data file with the models instead.
```{r}
readRDS()
```


Summarize the model fits
```{r, eval=F}
multiphy.AIC(prefix="fit", phylo=goanna.tree, models=c("BM", "OU", "PM_geo", 
                                                       "PMOU_geo", "OUM"))
```

If you wanted to simulate some data to see what it looks like under the inferred parameters
```{r, eval=F}
simulateTipData(modelBM, fitBM$inferredParams, method=2)
simulateTipData(modelPMOU_geo, fitPMOU_geo$inferredParams, method=2)
```

We could also quickly check that the inferred params result in simulated data that can recover the correct model:
```{r, eval=F}
testPMOUg <- simulateTipData(modelPMOU_geo, fitPMOU_geo$inferredParams, method=2)
test_modelBM <- createModel(goanna.tree, keyword="BM")
    test_fitBM <- fitTipData(test_modelBM, testPMOUg, GLSstyle=T)
test_modelPMOU_geo <- createGeoModel(goanna.tree, goanna.geo.object, keyword="PMOU+geo")
    test_fitPMOU_geo <- fitTipData(test_modelPMOU_geo, testPMOUg, GLSstyle=T)
multiphy.AIC(prefix="test_fit", goanna.tree, c("BM", "PMOU_geo"))
```

Reminder: you can check the composition of a model using '@', e.g.: 
```{r, eval=F}
modelGMM@aAGamma(3, ssGMM$inferredParams);
modelGMM@aAGamma(3, ssGMM$inferredParams)$A / ssGMM$inferredParams[5]
```











